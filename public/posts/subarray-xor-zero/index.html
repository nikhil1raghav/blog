<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Minimum changes to make XOR of all segments of a fixed length zero | Nikhil Raghav</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
<link rel="stylesheet" href="/assets/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">
<script defer src="/assets/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
<script defer src="/assets/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/books">Books</a></li>
      
      <li><a href="/links">Links</a></li>
      
      <li><a href="/posts">Posts</a></li>
      
      <li><a href="/subscribe">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Minimum changes to make XOR of all segments of a fixed length zero</span></h1>

<h2 class="date">2021/07/17</h2>
</div>

<main>
<h2 id="problem-statement">Problem Statement</h2>
<blockquote>
<p>Given an array $A$ of length $N$ and an integer $K$, find minimum number of elements to change in the array such that xor of all segments of size $K$ becomes zero.</p>
<p>where
$1 \leq K \leq N \leq 2000$ and $0 \leq A_i \leq 1024$</p>
</blockquote>
<p>As the window of size $K$ moves one step from first $K$ elements it leaves behind the first element and includes $K+1_{th}$ element. More formally</p>
<p>$$ A_1 \oplus A_2 \oplus A_3 \oplus \cdots \oplus A_K = A_2 \oplus A_3 \oplus A_4 \oplus \cdots \oplus A_{K+1}$$</p>
<p>Therefore, all numbers which are distance $K$ apart in the array must be equal.</p>
<p>$$ A_{i+bK} = const$$</p>
<p>So we can make groups of numbers and operate on those groups, as to get the end result every number in a group must be same. If a number is at position $i$ then it belongs to the group categorized by $i \% K$.</p>
<p>As an example if $K = 2$ then there will be two buckets to categorize all the numbers in. All numbers at odd positions in the array will belong to bucket $1$ and even positioned numbers will fall in bucket $0$.</p>
<p>At this step we have positions grouped together according to the remainder they give when divided by $K$, now we have to assign a number to every group such that xor of every subarray of length $K$ is zero.</p>
<hr>
<h5 id="what-will-be-the-cost-of-assigning-number-x-to-all-the-positions-in-a-group-g">What will be the cost of assigning number $X$ to all the positions in a group $G$?</h5>
<p>If total positions in group $G$ are $tot[G]$ and $cnt[G][X]$ is count of $X$ in group $G$. Then cost of assigning $X$ to group $G$ is equal to the numbers which are not equal to $X$ in group $G$, given by
$$tot[G]-cnt[G][X]$$</p>
<hr>
<p>If you write a na√Øve solution that tries every number in the range $[0, 1024]$ for every group and then checks if condition is met at the end. Then it will not scale for more than 2 groups i.e. $K&gt;2$ as it is of order of $1024^K$. Even sample cases have $K&gt;2$ for two cases.</p>
<hr>
<h3 id="slower-dp-solution">Slower DP solution</h3>
<p>Let $dp[i][xr]$ be the minimum changes to make in first $i$ groups such that <strong>xor</strong> of every subarray of length $i+1$ is $xr$ not considering the numbers in groups $i+1$ to $k-1$.</p>
<p>If we are considering a number $num$ to be the value of group $i$ then</p>
<p>$$dp[i][xr] = min ( \space dp[i][xr] \space, \space dp[i-1][xr \oplus num] \space + \space cost \space of \space assigning \space num)$$</p>
<p>or, $$ dp[i][xr] = min(\space dp[i][xr] \space, \space dp[i-1][xr \oplus num] \space + \space tot[i] - \space cnt[i][num]) $$</p>
<p>Now we can try every possible number for every group in a faster way and the final answer will be $dp[K-1][0]$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>K;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> xr<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;xr<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1024</span>;xr<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> num<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;num<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1024</span>;num<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(i<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				dp[i][xr]<span style="color:#f92672">=</span>tot[i]<span style="color:#f92672">-</span>cnt[i][xr];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				dp[i][xr]<span style="color:#f92672">=</span>min(dp[i][xr], dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][xr<span style="color:#f92672">^</span>num]<span style="color:#f92672">+</span>tot[i]<span style="color:#f92672">-</span>cnt[i][num]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout<span style="color:#f92672">&lt;&lt;</span>dp[K<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><p>Why is this slow ? It&rsquo;s complexity is $O(K*2^{20})$ which won&rsquo;t pass if $K \geq 500$ or some equivalent metric.</p>
<hr>
<h3 id="faster-dp-solution">Faster DP solution</h3>
<p>One observation is $cnt[G][num] = 0$ for some number $num$ then its cost is $tot[G]$. Therefore we can modify the innermost loop to check only for the numbers that exist in a particular group so it runs $\lceil \frac{N}K \rceil$ times for every $xr$ , and check for all other numbers in constant time.</p>
<p>It brings down the complexity to $O(N*1024)$ as every existent position will be used once for every value of $xr$.</p>
<p>Another way to understand is that outer loop runs $K$ times, inner loop $1024$ times and innermost loop runs for $\lceil \frac{N}K \rceil$ times.</p>
<p><strong>How to calculate dp for all the numbers that are not present in the array?</strong></p>
<p>Only task remaining is to take into account all the numbers that are not present in a group, and calculation for all of them can be done at once.</p>
<p>Key thing to notice is that for every $xr$ we should consider only one such number that is not present in the group, as it doesn&rsquo;t affect the cost which is always $tot[G]$, but allows us to choose the minimum value for $dp[i-1][xr \oplus num]$.</p>
<p>As we don&rsquo;t know what $num$ is beforehand (and we don&rsquo;t need to), just take the minimum value of $dp[i-1][for \space any \space xr]$ and call it $lastMinimum$.</p>
<p>So, best value of $dp[i][xr]$ for all other numbers not in the group will be</p>
<p>$$lastMinimum + tot[G]$$</p>
<p>In this code $group[i] $ is the set of numbers in group $i$.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> lastMinimum<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,tillnow<span style="color:#f92672">=</span>K;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>K;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	tillnow<span style="color:#f92672">=</span>n; <span style="color:#75715e">//to update lastminimum
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> xr<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;xr<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1024</span>;xr<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> num:group[i]){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(i<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				dp[i][xr]<span style="color:#f92672">=</span>tot[i]<span style="color:#f92672">-</span>cnt[i][xr];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				dp[i][xr]<span style="color:#f92672">=</span>min(dp[i][xr],dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][xr<span style="color:#f92672">^</span>num]<span style="color:#f92672">+</span>tot[i]<span style="color:#f92672">-</span>cnt[i][xr]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//for all numbers that are not in current group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		dp[i][xr]<span style="color:#f92672">=</span>min(dp[i][xr],lastMinimum<span style="color:#f92672">+</span>tot[i]);
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		tillnow<span style="color:#f92672">=</span>min(tillnow,dp[i][xr]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	lastMinimum<span style="color:#f92672">=</span>tillnow;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout<span style="color:#f92672">&lt;&lt;</span>dp[K<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><hr>
<p>You can practice this problem <a href="https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero/">here</a> on leetcode.</p>
<p><strong>Similar problems</strong></p>
<ul>
<li><a href="https://www.codechef.com/AGPR2020/problems/ALPR2005">XORGON - Codechef</a></li>
<li><a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. - Leetcode</a></li>
</ul>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

